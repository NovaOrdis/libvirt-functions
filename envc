#!/bin/bash

[ -f $(dirname $0)/../libvirt-functions/libvirt-functions ] && . $(dirname $0)/../libvirt-functions/libvirt-functions || { echo "$(dirname $0)/../libvirt-functions/libvirt-functions not found" 1>&2; exit 1; }

ALL_GUESTS="in appproxy support master1 master2 master3 infranode1 infranode2 node1 node2"

function main() {

    local command=$1

    [ -z "${command}" ] && {

        echo "[error]: a command must be specified" 1>&2;
        echo "available commands:" 1>&2;
        echo " start [vmid]" 1>&2;
        echo " stop [vmid]" 1>&2;
        echo " status [vmid]" 1>&2;
        echo " snapshot <snapshot_tag> [vmid]" 1>&2;
        echo " list-snapshots [vmid]" 1>&2;
        echo " restore <snapshot_tag> [vmid]" 1>&2;
        exit 1;
    }

    if [ "${command}" = "start" ]; then
        start $2;
    elif [ "${command}" = "stop" ]; then
        stop $2;
    elif [ "${command}" = "status" ]; then
        status $2;
    elif [ "${command}" = "snapshot" ]; then
        snapshot $2 $3;
    elif [ "${command}" = "list-snapshots" ]; then
        list-snapshots $2;
    elif [ "${command}" = "restore" ]; then
        restore $2 $3;
    else
        echo "[error]: unknown command '${command}'" 1>&2;
        exit 1;
    fi
}

#
# arg1 (optional) the vmid to be started
#
function start() {

    local names
    names=$(filter $1) || exit 1

    echo "starting ${names} ..."

    for i in ${names}; do
        virsh start ${i} || { echo "failed to start guest '${i}'" 1>&2; exit 1; }
    done
}

#
# arg1 (optional) the vmid to be stopped
#
function stop() {

    local names
    names=$(filter $1) || exit 1

    echo "stopping ${names} ..."

    for i in ${names}; do
        virsh shutdown ${i} || { echo "failed to shut down guest '${i}'" 1>&2; exit 1; }
    done

}

#
# arg1 (optional) the vmid to be reported
#
function status() {

    local names
    names=$(filter $1) || exit 1

    for i in ${names}; do
        local state
        state=$(virsh domstate ${i}) || exit 1
        printf "%-18s %s\n" "${i}:" "${state}"
    done
}

#
# Snapshots all qcow2 images of the environment, or just the specified image.
#
# arg1 (required) the snapshot tag
# arg2 (optional) the vmid to be snapshot. If not specified, all will be snapshot.
#
function snapshot() {

    local snapshot_tag=$1

    [ -z "${snapshot_tag}" ] && { echo "[error]: a snapshot tag must be specified" 1>&2; exit 1; }

    local names
    names=$(filter $2) || exit 1

    # make sure the target guests are down. If at least one is up, fail

    for i in ${names}; do
        local state
        state=$(virsh domstate ${i}) || exit 1
        if [ "${state}" != "shut off" ]; then
           echo "'${i}' is not shut down, cannot snapshot ..." 1>&2
           exit 1
        fi
    done

    # list the qcow2 images

    for i in ${names}; do
        local image_volume=/main-storage-pool/${i}.qcow2
        virsh vol-info ${image_volume} || { echo "failed to query ${image_volume}" 1>&2; exit 1; }
    done

    # snapshot all qcow2 images

    for i in ${names}; do
        local image_volume=/main-storage-pool/${i}.qcow2
        qemu-img snapshot -c ${snapshot_tag} ${image_volume} && echo "'${snapshot_tag}' applied to ${image_volume}" || exit 1
    done
}

#
# List disk image snapshots
#
# arg1 (optional) the vmid to query
#
#
function list-snapshots() {

    local names
    names=$(filter $1) || exit 1

    echo ""

    for i in ${names}; do
        local image_volume=/main-storage-pool/${i}.qcow2
        echo "Virtual machine: ${i}, image volume: ${image_volume}"
        qemu-img snapshot -l ${image_volume} || exit 1
        echo ""
    done
}

#
# Restores all (or just the specified) virtual machine qcow2 images to the given snapshot tag.
#
# arg1 (required) the snapshot tag
# arg2 (optional) the vmid to be restored. If not specified, all will be restored.
#
function restore() {

    local snapshot_tag=$1

    [ -z "${snapshot_tag}" ] && { echo "[error]: a snapshot tag must be specified" 1>&2; exit 1; }

    local names
    names=$(filter $2) || exit 1

    # make sure the target guests are down. If at least one is up, fail

    for i in ${names}; do
        local state
        state=$(virsh domstate ${i}) || exit 1
        if [ "${state}" != "shut off" ]; then
           echo "'${i}' is not shut down, cannot restore ..." 1>&2
           exit 1
        fi
    done

    # list the qcow2 images

    for i in ${names}; do
        local image_volume=/main-storage-pool/${i}.qcow2
        virsh vol-info ${image_volume} || { echo "failed to query ${image_volume}" 1>&2; exit 1; }
    done

    # restore

    for i in ${names}; do
        local image_volume=/main-storage-pool/${i}.qcow2
        qemu-img snapshot -a ${snapshot_tag} ${image_volume} && echo "${image_volume} restored to snapshot '${snapshot_tag}'" || exit 1
    done
}

#
# translation functions
#

#
# translates vmids to guest names (example: i to in, m1 to master1, etc.)
#
function vmid-to-guest-name() {

    local vmid=$1

    [ -z "${vmid}" ] && { echo "vmid-to-guest-name(): missing vmid" 1>&2; exit 1; }

    if [ "${vmid}" = "i" ]; then
        echo "in"
    elif [ "${vmid}" = "a" ]; then
        echo "appproxy"
    elif [ "${vmid}" = "s" ]; then
        echo "support"
    elif [ "${vmid}" = "m1" ]; then
        echo "master1"
    elif [ "${vmid}" = "m2" ]; then
        echo "master2"
    elif [ "${vmid}" = "m3" ]; then
        echo "master3"
    elif [ "${vmid}" = "i1" ]; then
        echo "infranode1"
    elif [ "${vmid}" = "i2" ]; then
        echo "infranode2"
    elif [ "${vmid}" = "n1" ]; then
        echo "node1"
    elif [ "${vmid}" = "n2" ]; then
        echo "node2"
    else
        echo "vmid-to-guest-name(): unknown vmid '${vmid}'" 1>&2
        exit 1
    fi
}

#
# filters the guest list based on arguments, and returns the result to stdout
#
# arg1 (optional) a specific vmid
#
function filter() {

    local vmid=$1

    [ -z "${vmid}" ] && { echo "${ALL_GUESTS}"; return 0; }

    local name
    name=$(vmid-to-guest-name ${vmid}) || exit 1

    [ -z "${name}" ] && { echo "filter: '${vmid}' did not select any guest name" 1>&2; exit 1; }

    echo "${name}"

}
main $@




